酒店房间的价格录入是通过时间段来录入的，比如10月1日至10月7日800元，10月8日至10月20日500元，
请实现以下函数int[][] merge(int[][] dateRangePrices)，输入是某个酒店多个日期段的价格
每个日期段（终止日期大于等于起始日期）和对应的价格使用长度为3的数组来表示，比如[0, 19, 300], [10, 40, 250]
分别表示从某天开始第1天到第20天价格都是300，第11天到第41天价格都是250，这些日期端有可能重复，重复的日期的价格以后面的为准， 
请以以下规则合并并输出合并结果：
1.相邻两天的价格如果相同，那么这两个日期段应该合并
2.合并的结果应该以起始日期从小到大排序
//这道题目可以定义一个结构体用于存储每个分段的起始时间，截止时间，价格，然后对所
//有相邻且价格一致的区间进行merge，这也是题目本身想要考察的。但是这样的做法不适
//合考试时候时间有限的情况下，虽然单纯的merge并不复杂，但是注意题目中提到了酒店
//的价格可能不一致，如果不一致，按后面的价格为准，如果后面记录的价格和前面的记录
//不一样，这就可能导致原来的一个区间段更新价格后分裂成为两个或者三个，略显复杂。
//所以可以直接用一个数组存储每天的价格，这样做的好处就是即使前后数据不一致，后面
//的会直接覆盖前面的完成价格更新，缺点就是需要一个数组来记录每天的价格，空间复杂
//度较高，对于这个实际问题而言，不会出现特别多的天数，所以不必考虑大数问题，当然
//也所幸内存够用。特别需要注意输出格式要满足题目要求。
#include <cstdio>
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    int s,e,p,i=0;
    while(cin>>s>>e>>p)
    {
        vector<long> price(10000);
        for(int i=s;i<=e;i++)
            price[i]=p;
        int minnum=s;
        int maxnum=e;
        while(cin>>s>>e>>p)
        {
            if(s<minnum)
                minnum=s;
            if(e>maxnum)
                maxnum=e;
            for(int i=s;i<=e;i++)
                price[i]=p;
        }
        cout << "[" << minnum << ", ";
        for(int i=minnum+1;i<=maxnum;i++)
        {
            if(price[i]!=price[i-1])
            {
                if(price[i-1]!=0)
                {
                    cout<<i-1<<", "<<price[i-1]<<"]";
                }
                if(i<maxnum&&price[i]!=0)
                {
                    cout<<","<<"["<<i<<", ";
                }
            }
        }
        cout<<maxnum<<", "<<price[maxnum]<<"]"<<endl;

    }
    return 0;

}
